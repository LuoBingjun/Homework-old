<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <title>The Buffer Bomb 大作业报告</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body>
        <h1 id="the-buffer-bomb-%E5%A4%A7%E4%BD%9C%E4%B8%9A%E6%8A%A5%E5%91%8A">The Buffer Bomb 大作业报告</h1>
<p>姓名：骆炳君</p>
<p>班级：软件71</p>
<p>学号：2017013573</p>
<h2 id="%E9%A2%98%E7%9B%AE%E8%AF%B4%E6%98%8E">题目说明</h2>
<h3 id="level0-candle">Level0: Candle</h3>
<p>在getbuf()函数中，返回地址存储在栈中0x55683214处，其值为0x08048bf3（指向test()函数中的下一行），利用缓冲区溢出将栈中地址0x55683214以下的区域值设为0x90，并将0x55683214处的值修改为0x08048b04（指向smoke()函数），就可以在getbuf()函数执行到ret指令时返回至smoke()函数.</p>
<h3 id="level1-sparkler">Level1: Sparkler</h3>
<p>分析fizz()函数中的指令可以得出，val变量存储在0x8(%ebp)中，对应地址为0x5568321c，即Level0中返回地址以上8个字节处，cookie变量是全局变量，存储地址为0x0804e104，在运行时值为0x2ef2f33f.</p>
<p>参考Level0中的操作，可以利用缓冲区溢出将getbuf()函数的返回地址设为0x08048b2e（指向fizz()函数），并将其以上8个字节的0x5568321c处的值（对应val）修改至与cookie相等，即可返回到fizz()并通过检验.</p>
<h3 id="level2-firecracker">Level2: Firecracker</h3>
<p>与Level0和1相比，Level2不仅要求修改栈中的值，还需要修改全局变量global_value的值，也就是要利用缓冲区溢出执行攻击者的汇编指令.</p>
<h4 id="%E8%AE%BE%E8%AE%A1%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81">设计汇编代码</h4>
<pre><code class="language-assemble"><div>   0:	bb 3f f3 f2 2e       	mov    $0x2ef2f33f,%ebx
   5:	89 1d 0c e1 04 08    	mov    %ebx,0x804e10c
   b:	68 82 8b 04 08       	push   $0x8048b82
  10:	c3                   	ret    
</div></code></pre>
<p>mov指令不允许直接把内存设置为立即数，运行程序发现%ebx未被使用，所以首先把0x2ef2f33f（cookie值）暂存到%ebx中.分析bang()中代码可得global_value变量的地址为0x804e10c，再把%ebx的值移入到这个地址.</p>
<p>完成修改操作后，程序需要返回到bang()函数，把0x8048b82（指向bang()函数）压入栈中，最后执行ret指令即可.</p>
<h4 id="%E5%B0%86%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E6%8F%92%E5%85%A5%E6%A0%88%E4%B8%AD%E5%B9%B6%E6%89%A7%E8%A1%8C">将汇编代码插入栈中并执行</h4>
<p>在本程序中，缓冲区注入攻击的最佳入口是getbuf()函数的返回地址.和前3个Level类似，可以将上述汇编代码插入到返回地址以上的栈中，再把函数getbuf()的返回地址设置为汇编代码的开头.</p>
<h3 id="level3-dynamite">Level3: Dynamite</h3>
<h4 id="%E8%AE%BE%E8%AE%A1%E6%B1%87%E7%BC%96">设计汇编</h4>
<pre><code class="language-assemble"><div>   0:	b8 3f f3 f2 2e       	mov    $0x2ef2f33f,%eax
   5:	bd 40 32 68 55       	mov    $0x55683240,%ebp
   a:	68 f3 8b 04 08       	push   $0x8048bf3
   f:	c3                   	ret   
</div></code></pre>
<p>分析getbuf()函数中的指令不难看出，其返回值存储在%eax寄存器中，使用mov指令就可以修改这个值.但同时，由于test()函数的栈底指针%ebp存储在getbuf()函数的返回地址以下4个字节处，在缓冲区溢出过程中会被覆盖掉，所以需要手动设置%ebp为正确的栈底地址.完成这些任务之后，将返回地址压入栈中，再执行ret指令即可.</p>
<h4 id="%E5%B0%86%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E6%8F%92%E5%85%A5%E6%A0%88%E4%B8%AD%E5%B9%B6%E6%89%A7%E8%A1%8C-1">将汇编代码插入栈中并执行</h4>
<p>这部分操作与Level2类似，但由于程序要返回到test()函数中继续执行，需要尽量减少对栈帧的破坏，所以选择将汇编代码插入到返回地址以下的栈中，这样返回到test()函数后不会损坏原有的栈帧.</p>
<h3 id="level4-nitroglycerin">Level4: Nitroglycerin</h3>
<h4 id="%E8%AE%BE%E8%AE%A1%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81-1">设计汇编代码</h4>
<pre><code class="language-assemble"><div>   0:	b8 3f f3 f2 2e       	mov    $0x2ef2f33f,%eax
   5:	ba 28 00 00 00       	mov    $0x28,%edx
   a:	8d 2c 14             	lea    (%esp,%edx,1),%ebp
   d:	68 67 8c 04 08       	push   $0x8048c67
  12:	c3                   	ret    
</div></code></pre>
<p>和Level3类似，首先将返回值设置为0x2ef2f33f（cookie值），然后手动设置%ebp.由观察可得栈顶与栈底间的长度为0x28，所以把%ebp设置为%esp+0x28.完成任务将返回地址压栈，并执行ret指令即可.</p>
<h4 id="%E5%B0%86%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E6%8F%92%E5%85%A5%E6%A0%88%E4%B8%AD%E5%B9%B6%E6%89%A7%E8%A1%8C-2">将汇编代码插入栈中并执行</h4>
<p>由于Level5中栈空间的随机性，从而导致缓冲区开始地址和返回值地址都在一定范围内变化.用gdb调试bufbomb -n，测得每一次运行的栈参数如下：</p>
<table>
<thead>
<tr>
<th>缓冲区开始地址</th>
<th>返回地址</th>
<th>长度</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x55683008</td>
<td>0x55683214</td>
<td>0x20c</td>
</tr>
<tr>
<td>0x55683008</td>
<td>0x55683214</td>
<td>0x20c</td>
</tr>
<tr>
<td>0x55683028</td>
<td>0x55683234</td>
<td>0x20c</td>
</tr>
<tr>
<td>0x55683058</td>
<td>0x55683264</td>
<td>0x20c</td>
</tr>
<tr>
<td>0x55682fd8</td>
<td>0x556831e4</td>
<td>0x20c</td>
</tr>
</tbody>
</table>
<p>可以发现，5次缓冲区溢出的公共地址段为0x55683058~0x556831e4，因此将0x55683058设置为getbufn()的返回地址，在返回地址以下的栈中插入汇编代码，并在汇编代码前全部用0x90占位.</p>
<h2 id="%E5%AE%9E%E9%AA%8C%E6%84%9F%E6%83%B3">实验感想</h2>
<p>实验非常有趣，帮助我理解了程序运行过程中栈的行为特点，还熟悉了gdb的调试操作，感谢助教的工作！</p>

    </body>
    </html>